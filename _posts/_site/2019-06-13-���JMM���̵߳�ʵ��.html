<p><strong>写这篇文章的目的，是想要从JVM的角度去介绍一下java多线程，自己也当是巩固复习吧，如有不对之处还需指正，评论功能需挂vpn才可见，没办法，Disqus国内无法访问，国家网络的闭关锁国很是苦恼啊…不吐槽了，下面开始</strong></p>

<p><strong>开篇介绍两个定律：</strong></p>
<ul>
  <li>Amdahl定律：通过系统中并行化与串行化的比重来描述多处理系统能获得运算加速能力。</li>
  <li>摩尔定律：用于描述处理器晶体管数量与运行效率之间的发展关系。</li>
</ul>

<p>并发处理的广泛应用使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因。</p>

<p><strong>首先，我们先来了解一下物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少的相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</strong></p>

<ul>
  <li>
    <p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为处理器与内存之间的缓冲：将运算使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。</p>
  </li>
  <li>
    <p>引入高速缓存后，又带来了一个新的问题：缓存一致性。所谓缓存一致性指的是在多处理器系统中，每个处理器都有自己的高速缓存，但是共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，那么同步回到主内存时以谁的数据为准？为了解决一致性问题，需要各个处理器访问缓存时，都遵循一些协议，在读写时要根据协议来操作，比如MSI， MESI，MOSI，Synapse，Firefly，Dragon Protocol等。</p>
  </li>
  <li>
    <p>除过处理器运算速度和内存速度矛盾，还有为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果进行重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。</p>
  </li>
</ul>

<p><img src="/assets/images/2019/06/13/详解JMM与线程的实现/处理器，高速缓存与主内存之间的交互关系.png" alt="处理器，高速缓存与主内存之间的交互关系" title="处理器，高速缓存与主内存之间的交互关系" /></p>

<h2 id="物理计算机的并发问题就介绍到这里接下来我们开始学习jvm的内存模型"><strong>物理计算机的并发问题就介绍到这里，接下来我们开始学习JVM的内存模型</strong></h2>

<p><strong>内存模型，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</strong></p>

<p>Java虚拟机定义了一种java内存模型（JMM）来屏蔽掉各种硬件和操作系的内存访问差异。这个模型一个是定义的足够严谨，使得java的并发内存访问操作不会产生歧义，另一个是也定义的足够宽松，使得虚拟机的实现有足够的空间去利用各种的硬件特性。</p>

<p>接下来，我们就来具体分析这种java内存模型：</p>

<h4 id="主内存与工作内存">主内存与工作内存</h4>
<ul>
  <li>刚才提到了，JMM是为了屏蔽各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台上都能达到一致的内存访问效果，它的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</li>
</ul>

<p><strong>注意1：此处的变量包括实例字段、静态字段和构成数组对象的元素，不包括局部变量和方法参数，因为后者是线程私有的，不会被共享就不会存在竞争问题。</strong></p>

<p><strong>注意2：JMM没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施&lt;指令重排序，后面会提到&gt;</strong></p>

<ul>
  <li>Java内存模型包括主内存和工作内存，JMM规定了所有的变量都存储在主内存中（这里的主内存相当于前面提到的主内存），工作内存是线程私有的，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝（工作内存类似于处理器高速缓存），线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需通过主内存来完成。</li>
</ul>

<p><img src="/assets/images/2019/06/13/详解JMM与线程的实现/线程、主内存、工作内存三者的交互关系.png" alt="线程、主内存和工作内存三者的交互关系" title="线程、主内存和工作内存三者的交互关系" /></p>

<p><strong>对底层来说，主内存及直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中。</strong></p>
